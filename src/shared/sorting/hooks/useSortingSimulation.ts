import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { SortingStep } from '../types';

export interface UseSortingSimulationOptions {
  steps: SortingStep[];
  autoplay?: boolean;
  initialSpeedMs?: number;
}

export interface UseSortingSimulationReturn {
  currentStepIndex: number;
  currentStep: SortingStep | null;
  totalSteps: number;
  isPlaying: boolean;
  speedMs: number;
  play: () => void;
  pause: () => void;
  next: () => void;
  previous: () => void;
  goToStep: (index: number) => void;
  setSpeedMs: (value: number) => void;
  reset: () => void;
}

/**
 * Shared simulation hook that manages play/pause/seek for sorting steps.
 * Expects that steps are already generated by the caller.
 */
export function useSortingSimulation({
  steps,
  autoplay = false,
  initialSpeedMs = 800
}: UseSortingSimulationOptions): UseSortingSimulationReturn {
  const [currentStepIndex, setCurrentStepIndex] = useState<number>(autoplay ? 0 : -1);
  const [isPlaying, setIsPlaying] = useState<boolean>(autoplay);
  const [speedMs, setSpeedMs] = useState<number>(initialSpeedMs);
  const timerRef = useRef<number | null>(null);

  const totalSteps = steps.length;
  const currentStep = useMemo(() => {
    if (currentStepIndex < 0 || currentStepIndex >= totalSteps) return null;
    return steps[currentStepIndex];
  }, [currentStepIndex, totalSteps, steps]);

  const clearTimer = () => {
    if (timerRef.current) {
      window.clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  };

  const goToStep = useCallback(
    (index: number) => {
      if (index < 0 || index >= totalSteps) return;
      setCurrentStepIndex(index);
    },
    [totalSteps]
  );

  const next = useCallback(() => {
    setCurrentStepIndex(prev => {
      if (prev + 1 >= totalSteps) {
        setIsPlaying(false);
        return prev;
      }
      return prev + 1;
    });
  }, [totalSteps]);

  const previous = useCallback(() => {
    setCurrentStepIndex(prev => Math.max(prev - 1, 0));
  }, []);

  const play = useCallback(() => {
    if (totalSteps === 0) return;
    if (currentStepIndex === -1) {
      setCurrentStepIndex(0);
    }
    setIsPlaying(true);
  }, [totalSteps, currentStepIndex]);

  const pause = useCallback(() => {
    setIsPlaying(false);
  }, []);

  const reset = useCallback(() => {
    clearTimer();
    setIsPlaying(false);
    setCurrentStepIndex(-1);
  }, []);

  // Clear timer on unmount
  useEffect(() => () => clearTimer(), []);

  // Restart when steps change
  useEffect(() => {
    reset();
    if (autoplay && steps.length > 0) {
      setCurrentStepIndex(0);
      setIsPlaying(true);
    }
  }, [steps, autoplay, reset]);

  // Auto-advance when playing
  useEffect(() => {
    clearTimer();
    if (!isPlaying) return;
    timerRef.current = window.setTimeout(() => {
      next();
    }, speedMs);
  }, [isPlaying, speedMs, next, currentStepIndex, totalSteps]);

  return {
    currentStepIndex,
    currentStep,
    totalSteps,
    isPlaying,
    speedMs,
    play,
    pause,
    next,
    previous,
    goToStep,
    setSpeedMs,
    reset
  };
}

